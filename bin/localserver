#!/usr/bin/env ruby

require 'securerandom'
require 'sinatra'
require 'json'

##
# Test server that mocks all the available endpoints of Todoable API
#
# The whole state is stored in memory, so both the authentication
# tokens stored in +AUTHENTICATION_TOKENS+ and data stored in +LISTS+
# are completely destroyed when the server is stopped.
class LocalServer < Sinatra::Base

  AUTHENTICATION_TOKENS = []

  LISTS = []

  LISTS_BY_ID = {}

  ##
  # Authentication endpoint
  #
  # Must be the first endpoint accessed. If the user & password match
  # whatever was provided when this server was run, the endpoint will
  # generate a token that can be used to access the other endpoints

  post "/api/authenticate" do
    unless authorized?
      response['WWW-Authenticate'] = "Basic"
      throw(:halt, [401])
    end

    new_token = SecureRandom.uuid.to_s
    AUTHENTICATION_TOKENS << new_token

    content_type :json
    { :token => new_token }.to_json
  end

  ##
  # Retrieve all lists available in the server
  #
  # Since there's no multi-user features in this server, all the lists
  # are retrieved when the user hits this endpoint

  get "/api/lists" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json
    return {"lists" => LISTS}.to_json
  end

  ##
  # Create a new list
  #
  # The payload has to contain the following structure:
  #   {"list": {"name": "Urgent Things"}}
  # Otherwise 422 is returned

  post "/api/lists" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json

    # Create new list structure
    name = list_name_from_request
    id = SecureRandom.uuid.to_s
    src = "#{settings.srvuri}/api/lists/#{id}"
    new_list = {'name' => name, 'id' => id, 'src' => src}

    # Save on the memory buffers
    LISTS << new_list
    LISTS_BY_ID[id] = new_list

    # Return the created object to the user
    new_list.to_json
  end

  ##
  # Retrieve a single list

  get "/api/lists/:id" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json
    list = LISTS_BY_ID[params[:id]]
    list.to_json
  end

  ##
  # Update list name

  patch "/api/lists/:id" do
    #throw(:halt, [401]) unless token_authorized?

    name = list_name_from_request
    list = LISTS_BY_ID[params[:id]]
    list['name'] = name

    "#{name} updated"
  end

  ##
  # Delete a list by its ID
  #
  # This gets rid of the two existing references that point to a list,
  # in LISTS & LISTS_BY_ID

  delete "/api/lists/:id" do
    #throw(:halt, [401]) unless token_authorized?

    LISTS_BY_ID.delete params[:id]
    LISTS.delete_if { |l| l['id'] == params[:id] }
    throw(:halt, [204])
  end

  private

  ##
  # Parse list name for POST on /api/lists & PATCH on /api/lists/:list_id

  def list_name_from_request
    begin
      json_body = JSON.parse request.body.read
    rescue JSON::ParserError
      throw(:halt, [422])
    end
    if json_body['list'] == nil || json_body['list']['name'] == nil
      throw(:halt, [422, {"name" => ["can't be blank"]}.to_json])
    end
    json_body['list']['name']
  end

  ##
  # User/Password based authentication endpoint `/api/authenticate`
  #
  # The user and password are set via command line when the process is
  # started.

  def authorized?
    auth = Rack::Auth::Basic::Request.new request.env
    (auth.provided? &&
     auth.basic? &&
     auth.credentials &&
     auth.credentials == [settings.username, settings.password])
  end

  ##
  # Verify if requests contain a token generated by this process
  #
  # It looks for `HTTP_AUTHORIZATION` within `request.env`. If it's
  # found, it grabs the token and verifies it was generated by this
  # server.

  def token_authorized?
    token = request.env['HTTP_AUTHORIZATION']
    AUTHENTICATION_TOKENS.include? token.slice(13..-2)
  end
end


##
# Parse command line to get user & password for endpoint /authenticate

def handle_command_line
  if ARGV.length < 2 || ARGV.length > 4
    STDERR.puts "Usage: #{__FILE__} <username> <password> [uri]"
    exit 1
  end

  LocalServer.set :username, ARGV[0]
  LocalServer.set :password, ARGV[1]
  LocalServer.set :srvuri, ARGV[2] || 'http://localhost:4567'
  LocalServer.run!
end

if $0 == __FILE__
  handle_command_line
end
