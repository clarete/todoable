#!/usr/bin/env ruby

require 'securerandom'
require 'sinatra'
require 'json'

##
# Test server that mocks all the available endpoints of Todoable API
#
# The whole state is stored in memory, so both the authentication
# tokens stored in +AUTHENTICATION_TOKENS+ and data stored in +LISTS+
# are completely destroyed when the server is stopped.
class LocalServer < Sinatra::Base

  AUTHENTICATION_TOKENS = []

  LISTS = []

  LISTS_BY_ID = {}

  ITEMS = {}

  ITEMS_BY_ID = {}

  ##
  # Authentication endpoint
  #
  # Must be the first endpoint accessed. If the user & password match
  # whatever was provided when this server was run, the endpoint will
  # generate a token that can be used to access the other endpoints

  post "/api/authenticate" do
    unless authorized?
      response['WWW-Authenticate'] = "Basic"
      throw(:halt, [401])
    end

    new_token = SecureRandom.uuid.to_s
    AUTHENTICATION_TOKENS << new_token

    content_type :json
    { :token => new_token }.to_json
  end

  ##
  # Retrieve all lists available in the server
  #
  # Since there's no multi-user features in this server, all the lists
  # are retrieved when the user hits this endpoint

  get "/api/lists" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json
    return {"lists" => LISTS}.to_json
  end

  ##
  # Create a new list
  #
  # The payload has to contain the following structure:
  #   {"list": {"name": "Urgent Things"}}
  # Otherwise 422 is returned

  post "/api/lists" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json

    # Create new list structure
    name = name_from_request "list"
    id = SecureRandom.uuid.to_s
    src = "#{settings.srvuri}/api/lists/#{id}"
    new_list = {'name' => name, 'id' => id, 'src' => src}

    # Save on the memory buffers
    LISTS << new_list
    LISTS_BY_ID[id] = new_list
    ITEMS[id] = []

    # Return the created object to the user
    new_list.to_json
  end

  ##
  # Retrieve a single list

  get "/api/lists/:id" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json
    list = LISTS_BY_ID[params[:id]]
    throw(:halt, [404]) if list == nil

    {'name' => list['name'], 'items' => ITEMS[params[:id]] || []}.to_json
  end

  ##
  # Update list name

  patch "/api/lists/:id" do
    #throw(:halt, [401]) unless token_authorized?
    name = name_from_request "list"
    list = LISTS_BY_ID[params[:id]]

    throw(:halt, [404]) if list == nil
    list['name'] = name
    "#{name} updated"
  end

  ##
  # Delete a list by its ID
  #
  # This gets rid of the two existing references that point to a list,
  # in LISTS & LISTS_BY_ID

  delete "/api/lists/:id" do
    #throw(:halt, [401]) unless token_authorized?
    throw(:halt, [404]) if LISTS_BY_ID[params[:id]] == nil

    LISTS_BY_ID.delete params[:id]
    LISTS.delete_if { |l| l['id'] == params[:id] }
    throw(:halt, [204])
  end

  ##
  # Create a new item within a list
  #
  # The payload has to contain the following structure:
  #   {"item": {"name": "Urgent Things"}}
  # Otherwise 422 is returned

  post "/api/lists/:list_id/items" do
    #throw(:halt, [401]) unless token_authorized?
    content_type :json
    list_id = params[:list_id]

    # Create new list structure
    name = name_from_request "item"
    id = SecureRandom.uuid.to_s
    src = "#{settings.srvuri}/api/lists/#{list_id}/items/#{id}"
    new_item = {
      'name' => name,
      'id' => id,
      'src' => src,
      'finished_at' => nil,
    }

    # Save on the memory buffers
    ITEMS[list_id] << new_item
    ITEMS_BY_ID[id] = new_item

    # Return the created object to the user
    new_item.to_json
  end

  ##
  # Mark a TODO item as finished

  put "/api/lists/:list_id/items/:item_id/finish" do
    #throw(:halt, [401]) unless token_authorized?
    item = ITEMS_BY_ID[params[:item_id]]
    throw(:halt, [404]) if item == nil

    item['finished_at'] = Time.now.utc.iso8601
    "#{item['name']} finished"
  end

  ##
  # Delete a TODO item

  delete "/api/lists/:list_id/items/:item_id" do
    #throw(:halt, [401]) unless token_authorized?
    throw(:halt, [404]) if LISTS_BY_ID[params[:list_id]] == nil
    throw(:halt, [404]) if ITEMS_BY_ID[params[:item_id]] == nil

    ITEMS_BY_ID.delete params[:item_id]
    ITEMS[params[:list_id]].delete_if { |i| i['id'] == params[:item_id] }
    throw(:halt, [204])
  end

  private

  ##
  # Parse list name for POST on /api/lists & PATCH on /api/lists/:list_id

  def name_from_request object_name
    begin
      json_body = JSON.parse request.body.read
    rescue JSON::ParserError
      throw(:halt, [422])
    end
    if json_body[object_name] == nil || json_body[object_name]['name'] == nil
      throw(:halt, [422, {"name" => ["can't be blank"]}.to_json])
    end
    json_body[object_name]['name']
  end

  ##
  # User/Password based authentication endpoint `/api/authenticate`
  #
  # The user and password are set via command line when the process is
  # started.

  def authorized?
    auth = Rack::Auth::Basic::Request.new request.env
    (auth.provided? &&
     auth.basic? &&
     auth.credentials &&
     auth.credentials == [settings.username, settings.password])
  end

  ##
  # Verify if requests contain a token generated by this process
  #
  # It looks for `HTTP_AUTHORIZATION` within `request.env`. If it's
  # found, it grabs the token and verifies it was generated by this
  # server.

  def token_authorized?
    token = request.env['HTTP_AUTHORIZATION']
    AUTHENTICATION_TOKENS.include? token.slice(13..-2)
  end
end


##
# Parse command line to get user & password for endpoint /authenticate

def handle_command_line
  if ARGV.length < 2 || ARGV.length > 4
    STDERR.puts "Usage: #{__FILE__} <username> <password> [uri]"
    exit 1
  end

  LocalServer.set :username, ARGV[0]
  LocalServer.set :password, ARGV[1]
  LocalServer.set :srvuri, ARGV[2] || 'http://localhost:4567'
  LocalServer.run!
end

if $0 == __FILE__
  handle_command_line
end
